<script type="module">
  'use strict'
  // ======= CONFIG =======
  const TMDB_API_KEY = "166bdfecdc09d46826d8662b9627ad27";
  const TMDB_IMG_BASE = "https://image.tmdb.org/t/p/";
  const LANGUAGE = "ru";
  const YOUTUBE_API_KEY = "AIzaSyCUHWrkVFi1UO1y8NKSkWtrT_W1aZpdBDM";
  const SEARCH_DELAY_MS = 350;
  const ALLOWED_DEVICE_ID = "30a62442-ecd5-4abf-9b51-22b34ae85d2e|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36";

  // Firebase
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
  import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js";
  // Interact.js
  import * as interact from 'https://cdn.jsdelivr.net/npm/interactjs@latest/dist/interact.min.js';

  const firebaseConfig = {
    apiKey: "AIzaSyDu8R38EkqOxBDkcgfnYf5mBTCosQsOoGA",
    authDomain: "my-movie-tv-lis.firebaseapp.com",
    projectId: "my-movie-tv-lis",
    storageBucket: "my-movie-tv-lis.firebasestorage.app",
    messagingSenderId: "470112487115",
    appId: "1:470112487115:web:a0dba8f948514eaf3e3d4e",
    measurementId: "G-JLCYQH6XEE"
  };

  const app = initializeApp(firebaseConfig);
  const database = getDatabase(app);

  // ======= STATE =======
  const state = {
    items: /** @type {Record<string, any>} */ ({}),
    order: /** @type {string[]} */ ([]),
    selectedIndex: -1,
    suggestions: [],
  };

  // ======= DOM =======
  const $ = (sel, ctx=document) => ctx.querySelector(sel);
  const $$ = (sel, ctx=document) => [...ctx.querySelectorAll(sel)];
  const esc = (s="") => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
  const debounce = (fn, ms) => { let t; return (...a) => { clearTimeout(t); t=setTimeout(() => fn(...a), ms); }; };

  const el = {
    searchbar: $('#searchbar'),
    search: $('#search'),
    suggestions: $('#suggestions'),
    list: $('#list'),
    loader: $('#loader'),
    modal: $('#modal'),
    modalTitle: $('#modal-title'),
    confirmDelete: $('#confirm-delete'),
    cancelDelete: $('#cancel-delete'),
    editModal: $('#edit-modal'),
    trailerInput: $('#trailer-link-input'),
    saveTrailer: $('#save-trailer'),
    cancelEdit: $('#cancel-edit'),
  };

  // ======= DEVICE CHECK =======
  function getDeviceId() {
    let deviceId = localStorage.getItem('deviceId');
    if (!deviceId) {
      deviceId = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = Math.random()*16|0, v = c==='x'? r : (r&0x3|0x8); return v.toString(16);
      });
      localStorage.setItem('deviceId', deviceId);
    }
    return deviceId + '|' + navigator.userAgent;
  }
  const allowedDevice = getDeviceId() === ALLOWED_DEVICE_ID;

  // Make list visibly sortable for allowed device
  if (allowedDevice) el.list.classList.add('sortable');

  // ======= API HELPERS =======
  function apiUrl(path, params = {}) {
    const base = new URL('https://api.themoviedb.org/3' + path);
    const sp = new URLSearchParams({ api_key: TMDB_API_KEY, language: LANGUAGE, ...params });
    base.search = sp.toString();
    return base.toString();
  }
  const imgUrl = (path, size='w500') => path ? `${TMDB_IMG_BASE}${size}${path}` : '';

  // ======= YOUTUBE =======
  async function searchYouTubeTrailer(title) {
    const q = `${encodeURIComponent(title)} трейлер русский`;
    const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${q}&key=${YOUTUBE_API_KEY}&regionCode=RU&maxResults=1&type=video`;
    try {
      const res = await fetch(url);
      const data = await res.json();
      if (data?.items?.length) return `https://www.youtube.com/watch?v=${data.items[0].id.videoId}`;
    } catch (e) {
      console.warn('YouTube API error:', e);
    }
    return null;
  }

  // ======= TMDB =======
  async function searchMulti(q) {
    if (!TMDB_API_KEY) return { results: [] };
    const url = apiUrl('/search/multi', { query: q, include_adult: 'false' });
    try {
      const res = await fetch(url);
      if (!res.ok) return { results: [] };
      const data = await res.json();
      const items = (data?.results||[]).filter(r=>r.media_type==='movie'||r.media_type==='tv').slice(0,12);
      return { results: items };
    } catch (e) {
      console.warn('TMDb search error:', e);
      return { results: [] };
    }
  }

  async function fetchDetails(type, id) {
    const url = apiUrl(`/${type}/${id}`, { append_to_response: 'videos' });
    const res = await fetch(url);
    return await res.json();
  }

  function bestTrailerUrl(details) {
    const vids = details?.videos?.results || [];
    const pick = vids.find(v => v.site==='YouTube' && v.type==='Trailer' && v.official && v.iso_639_1==='ru')
      || vids.find(v => v.site==='YouTube' && v.type==='Trailer' && v.iso_639_1==='ru')
      || vids.find(v => v.site==='YouTube' && v.type==='Teaser' && v.iso_639_1==='ru');
    return pick ? `https://www.youtube.com/watch?v=${pick.key}` : '';
  }

  // ======= SAVE / LOAD (Firebase) =======
  function save() {
    set(ref(database, 'tmdbList'), { items: state.items, order: state.order })
      .catch(err => console.error('Ошибка сохранения:', err));
  }

  function subscribe() {
    onValue(ref(database, 'tmdbList'), (snapshot) => {
      const data = snapshot.val();
      if (data) {
        state.items = data.items || {};
        state.order = data.order || [];
        for (const k of Object.keys(state.items)) {
          const m = state.items[k];
          if (!m.customTrailerUrl) m.customTrailerUrl = bestTrailerUrl(m) || '';
        }
      }
      renderList();
    }, (error) => console.error('Ошибка загрузки:', error));
  }

  // ======= SUGGESTIONS UI =======
  function openSuggestions(items) {
    state.suggestions = items;
    el.suggestions.innerHTML = items.map((it, idx) => {
      const title = it.title || it.name || '';
      const year = (it.release_date || it.first_air_date || '').slice(0,4);
      const poster = it.poster_path ? imgUrl(it.poster_path, 'w154') : '';
      return `<div class="suggestion" role="option" data-type="${esc(it.media_type)}" data-id="${esc(it.id)}" aria-selected="${idx===state.selectedIndex}">
        <img src="${esc(poster)}" alt="" loading="lazy" />
        <div class="meta">
          <div style="font-weight:700">${esc(title)}</div>
          <div class="pill">${esc(year||'')}</div>
        </div>
        <div class="pill">${esc(it.media_type)}</div>
      </div>`;
    }).join('');
    el.suggestions.classList.add('open');
    el.searchbar.setAttribute('aria-expanded', 'true');
  }
  function closeSuggestions() {
    el.suggestions.classList.remove('open');
    el.searchbar.setAttribute('aria-expanded', 'false');
    state.selectedIndex = -1; state.suggestions = [];
  }

  // ======= RENDER LIST =======
  function cardTemplate(m, key) {
    const poster = m.poster_path ? imgUrl(m.poster_path, 'w500') : '';
    const title = m.title || m.name || '';
    const year = (m.release_date || m.first_air_date || '').slice(0,4) || '';
    const genres = (m.genres||[]).slice(0,3).map(g=>`<span class="pill">${esc(g.name)}</span>`).join('');
    const rating = (m.vote_average && m.vote_count>0) ? `⭐${Number(m.vote_average).toFixed(1)}` : '';
    const runtime = (m.runtime ? `${m.runtime} min` : (Array.isArray(m.episode_run_time) && m.episode_run_time[0]) ? `${m.episode_run_time[0]} min` : '');
    const description = m.overview ? `<p class="description">${esc(m.overview)}</p>` : '';
    return `<article class="card" data-key="${esc(key)}" aria-grabbed="false">
      <img class="poster" src="${esc(poster)}" alt="Poster for ${esc(title)}" loading="lazy" />
      <div class="content">
        <h3 style="margin:0 0 6px">${esc(title)} ${year ? `<span class="pill" style="margin-left:6px">${esc(year)}</span>` : ''}</h3>
        <div class="row">${genres}</div>
        ${description}
      </div>
      <div class="actions">
        <div class="row" style="gap:8px">
          ${rating ? `<span class="pill">${esc(rating)}</span>` : ''}
          ${runtime ? `<span class="pill">${esc(runtime)}</span>` : ''}
          <span class="pill">${esc(m.media_type.toUpperCase())}</span>
        </div>
        <div class="row" style="gap:8px">
          <a class="btn-ghost" href="#" data-trailer="${esc(key)}" rel="noreferrer">Трейлер</a>
          <button class="btn-ghost" data-remove="${esc(key)}" title="Удалить">Удалить</button>
          ${allowedDevice ? `<button class="btn-ghost" data-edit="${esc(key)}" title="Редактировать трейлер">⚙️</button>` : ''}
        </div>
      </div>
    </article>`;
  }

  function renderList() {
    el.list.classList.remove('loading');
    el.loader.style.display = 'none';
    if (!state.order.length) {
      el.list.innerHTML = `<div class="card wide"><div class="content"><h3 style="margin:6px 0 6px">Your list is empty</h3><p class="subtitle">Search above and click a result to add a movie or TV show.</p></div></div>`;
      return;
    }
    console.log('Rendering list with order:', state.order);
    el.list.innerHTML = state.order.map(key => cardTemplate(state.items[key], key)).join('');
  }

  // ======= ADD =======
  async function addItem(type, id) {
    const key = `${type}_${id}`;
    if (state.items[key]) return;
    const m = await fetchDetails(type, id);
    if (m && !m.status_code) {
      m.media_type = type;
      m.customTrailerUrl = await searchYouTubeTrailer(m.title || m.name || '') || bestTrailerUrl(m) || '';
      state.items[key] = m;
      state.order.unshift(key);
      save();
      renderList();
    }
  }

  // ======= MODALS HELPERS =======
  function openConfirmModal(title, key, card) {
    el.modalTitle.textContent = title;
    el.modal.style.display = 'flex';
    const close = () => { el.modal.style.display = 'none'; cleanup(); };
    const cleanup = () => {
      el.confirmDelete.removeEventListener('click', confirmHandler);
      el.cancelDelete.removeEventListener('click', close);
      el.modal.removeEventListener('click', backdrop);
    };
    const confirmHandler = () => {
      console.log('Confirming deletion for key:', key);
      if (card) {
        card.classList.add('removing');
        setTimeout(() => {
          console.log('Fade animation completed, removing item:', key);
          delete state.items[key];
          state.order = state.order.filter(x => x !== key);
          save();
          renderList();
        }, 500);
      } else {
        console.error('Card not found for key:', key);
        delete state.items[key];
        state.order = state.order.filter(x => x !== key);
        save();
        renderList();
      }
      close();
    };
    const backdrop = (e) => { if (e.target === el.modal) close(); };
    el.confirmDelete.addEventListener('click', confirmHandler, { once: true });
    el.cancelDelete.addEventListener('click', close);
    el.modal.addEventListener('click', backdrop);
  }

  function openEditModal(currentUrl, onSave) {
    el.trailerInput.value = currentUrl || '';
    el.editModal.style.display = 'flex';
    const close = () => { el.editModal.style.display = 'none'; cleanup(); };
    const cleanup = () => {
      el.saveTrailer.removeEventListener('click', saveHandler);
      el.cancelEdit.removeEventListener('click', close);
      el.editModal.removeEventListener('click', backdrop);
    };
    const saveHandler = () => { onSave(el.trailerInput.value.trim()); close(); };
    const backdrop = (e) => { if (e.target === el.editModal) close(); };
    el.saveTrailer.addEventListener('click', saveHandler, { once: true });
    el.cancelEdit.addEventListener('click', close);
    el.editModal.addEventListener('click', backdrop);
  }

  // ======= SEARCH EVENTS =======
  const doSearch = debounce(async () => {
    const q = el.search.value.trim();
    if (!q) { closeSuggestions(); return; }
    const data = await searchMulti(q);
    if (!data || data.Error) {
      el.suggestions.innerHTML = `<div class="suggestion" aria-disabled="true">${esc(data?.Error || 'No results')}</div>`;
      el.suggestions.classList.add('open');
      return;
    }
    openSuggestions(data.results);
  }, SEARCH_DELAY_MS);

  function highlight() {
    $$('.suggestion', el.suggestions).forEach((n, i) => n.setAttribute('aria-selected', String(i===state.selectedIndex)));
  }

  // ======= DRAG & DROP with Interact.js =======
  function initCustomDnD() {
    if (!allowedDevice) return;
    const container = el.list;

    // Enable draggable on .card elements
    interact('.card').draggable({
      // Restrict dragging to container
      modifiers: [
        interact.modifiers.restrict({
          restriction: container,
          elementRect: { top: 0, left: 0, bottom: 1, right: 1 },
        }),
      ],
      // Ignore buttons
      ignoreFrom: '.btn-ghost, button',
      listeners: {
        start(event) {
          const target = event.target;
          target.classList.add('dragging');
          target.setAttribute('aria-grabbed', 'true');
          document.body.classList.add('noselect');
          console.log('Drag started:', target.getAttribute('data-key'));
        },
        move: debounce((event) => {
          // No visual movement needed, just maintain drag state
        }, 10),
        end(event) {
          const target = event.target;
          target.classList.remove('dragging');
          target.setAttribute('aria-grabbed', 'false');
          document.body.classList.remove('noselect');

          const dragKey = target.getAttribute('data-key');
          const y = event.clientY;
          const cards = $$('.card:not(.dragging)', container);
          let dropIndex = state.order.length; // Default: append to end

          if (cards.length) {
            const positions = cards.map((card, i) => {
              const rect = card.getBoundingClientRect();
              const centerY = rect.top + rect.height / 2;
              return { card, index: i, centerY, distance: Math.abs(y - centerY) };
            });
            positions.sort((a, b) => a.distance - b.distance);
            const closest = positions[0];
            dropIndex = closest.index + (y <= closest.centerY ? 0 : 1);
          }

          const newOrder = state.order.filter(key => key !== dragKey);
          newOrder.splice(dropIndex, 0, dragKey);
          state.order = newOrder;
          console.log('New order after drop:', state.order);
          save();
          renderList();
        },
      },
    });

    // Enable dropzone on container
    interact(container).dropzone({
      accept: '.card',
      ondrop: (event) => {
        // Handled in draggable end, no additional logic needed
      },
    });
  }

  // ======= BOOT =======
  document.addEventListener('DOMContentLoaded', () => {
    if (!allowedDevice) {
      el.searchbar.style.display = 'none';
    } else {
      el.search.addEventListener('input', doSearch);
      el.search.addEventListener('keydown', (e) => {
        if (!el.suggestions.classList.contains('open')) return;
        const max = state.suggestions.length - 1;
        if (e.key === 'ArrowDown') { e.preventDefault(); state.selectedIndex = Math.min(max, state.selectedIndex + 1); highlight(); }
        else if (e.key === 'ArrowUp') { e.preventDefault(); state.selectedIndex = Math.max(0, state.selectedIndex - 1); highlight(); }
        else if (e.key === 'Enter') {
          if (state.selectedIndex >= 0) {
            const sel = state.suggestions[state.selectedIndex]; if (sel) addItem(sel.media_type, sel.id);
          } else if (state.suggestions[0]) {
            const sel = state.suggestions[0]; addItem(sel.media_type, sel.id);
          }
          closeSuggestions();
          el.search.select();
        } else if (e.key === 'Escape') { closeSuggestions(); }
      });

      el.suggestions.addEventListener('click', (e) => {
        const item = e.target.closest('.suggestion');
        if (!item) return;
        const id = item.getAttribute('data-id');
        const type = item.getAttribute('data-type');
        if (id && type) { addItem(type, id); closeSuggestions(); el.search.select(); }
      });

      document.addEventListener('click', (e) => {
        if (!el.searchbar.contains(e.target)) closeSuggestions();
      });
    }

    // Делегирование кликов по карточкам
    el.list.addEventListener('click', async (e) => {
      const delBtn = e.target.closest('[data-remove]');
      const editBtn = e.target.closest('[data-edit]');
      const trailerLink = e.target.closest('[data-trailer]');

      if (delBtn) {
        const key = delBtn.getAttribute('data-remove');
        const m = state.items[key];
        if (!m) {
          console.error('Item not found in state for key:', key);
          return;
        }
        const title = m.title || m.name || 'Неизвестное произведение';
        const card = el.list.querySelector(`.card[data-key="${key}"]`);
        if (!card) {
          console.error('Card not found for key:', key);
        }
        openConfirmModal(title, key, card);
        return;
      }

      if (editBtn && allowedDevice) {
        const key = editBtn.getAttribute('data-edit');
        const m = state.items[key];
        if (!m) return;
        openEditModal(m.customTrailerUrl || '', (val) => {
          m.customTrailerUrl = val || '';
          save();
          renderList();
        });
        return;
      }

      if (trailerLink) {
        e.preventDefault();
        const key = trailerLink.getAttribute('data-trailer');
        const m = state.items[key];
        if (!m) return;
        const title = m.title || m.name || '';
        let url = m.customTrailerUrl || bestTrailerUrl(m);
        if (!url) url = await searchYouTubeTrailer(title);
        if (url) window.open(url, '_blank');
        else alert('Трейлер не найден.');
      }
    });

    // Firebase подписка
    subscribe();

    // Инициализация Drag&Drop
    initCustomDnD();
  });
</script>
